## CDN

CDN（Content Delivery Network，内容分发网络）指的是一组分布在各个地区的服务器。
这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。
CDN 提供快速服务，较少受高流量影响。
假设有一部影片出版，非常多人看。jsliang 在广州，请求上海的服务器，结果这个服务器非常多人，资源响应地很慢。于是 jsliang 切换了路线，看到深圳服务器也有这个资源，于是向深圳服务器请求，结果能很快地看到这部影片。
在这个场景中，深圳服务器就扮演 CDN 的角色。
CDN 的核心：**缓存**和 **回源**。

* **缓存**：将资源 copy 一份到 CDN 服务器。
* **回源**：CDN 发现自己没有这个资源，转头向根服务器（上级服务器）请求这个资源。

应用场景：

1. 公司静态资源部署到就近的服务器，利用 CDN 特性方便访问
2. jQuery 等框架可以引用 CDN，加快网站的加载速度，避免同一个服务器加载的限制。
3. 减少 Cookie 影响。同一个域名下，请求静态资源会携带 Cookie 信息，但是我们并不需要，所以使用 CDN 可以避免不必要的 Cookie 出现场景。

## 负载均衡

如果是大型网站，负载均衡是不可或缺的内容。

* PM2：一款 Node.js 进程管理器，让计算机每一个内核都启动一个 Node.js 服务，并且实现自动控制负载均衡。
* Nginx：通过轮询机制，将用户的请求分配到压力较小的服务器上（反向代理）。

区别：反向代理是对服务器实现负载均衡，而 PM2 是对进程实现负载均衡

## Webpack 优化

* 优化 resolve.modules 配置

resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块，默认是 ['node_modules']，但是，它会先去当前目录的 ./node_modules 查找，没有的话再去 ../node_modules，最后到根目录。

``` js
  resolve: {
      modules: [path.resolve(__dirname, 'node_modules')],
  }
```

* 优化 resolve.extensions 配置

在导入没带文件后缀的路径时，Webpack 会自动带上后缀去尝试询问文件是否存在，而 resolve.extensions 用于配置尝试后缀列表；默认为 extensions:['js', 'json']。
当遇到 require('./data') 时 Webpack 会先尝试寻找 data.js，没有再去找 data.json；如果列表越长，或者正确的后缀越往后，尝试的次数就会越多。
所以在配置时为提升构建优化需遵守：

1. 频率出现高的文件后缀优先放在前面。
2. 列表尽可能的少，例如只有 3 个：js、jsx、json。
3. 书写导入语句时，尽量写上后缀名。

* babel-loader

babel-loader 为例，可以通过 include 和 exclude 帮助我们避免 node_modules 这类庞大文件夹。

* tree shaking

通过 ES6 的 import/export 来检查未引用代码，以及 sideEffects 来标记无副作用代码，最后用 UglifyJSPlugin 来做 tree shaking，从而删除冗余代码。

* 多进程 

Happypack 可以将任务分解成多个子进程去并发执行，大大提升打包效率。消耗性能，不用建议关闭。

* 多进程代码压缩

因为自带的 UglifyJsPlugin 压缩插件是单线程运行的，而 ParallelUglifyPlugin 可以并行执行。
所以通过 ParallelUglifyPlugin 代替自带的 UglifyJsPlugin 插件。

* 抽离

通过 DllPlugin 或者 Externals 进行静态依赖包的分离。
由于 CommonsChunkPlugin 每次构建会重新构建一次 vendor，所以出于效率考虑，使用 DllPlugin 将第三方库单独打包到一个文件中，只有依赖自身发生版本变化时才会重新打包。

* 打包资源压缩

1. JS 压缩：UglifyJSPlugin
2. HTML 压缩：HtmlWebpackPlugin
3. 提取公共资源：splitChunks.cacheGroups
4. CSS 压缩：MiniCssExtractPlugin
5. Gzip 压缩：不包括图片

* 拆包

SplitChunksPlugin

* 按需加载

通过 Code-Splitting 来做 React 的按需加载.
Code_Splitting 核心是 require-ensure

## 图片优化

* JPEG 与 JPG

关键字：有损压缩、体积小、加载快、不支持透明
优点：压缩一定程度能保持品质、体积小、请求速度快
缺点：处理矢量图形、Logo 等线条感较强，颜色对比强烈的图形，人为压缩会导致图片模糊明显。不支持透明度处理。
使用场景：大的背景图、轮播图或者 Banner 图。

* PNG-8 与 PNG-24

关键字：无损压缩、质量高、体积大、支持透明
优点：PNG-8 支持 256 种颜色，PNG-24 支持 1600 种颜色。更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。
缺点：体积较大
使用场景：Logo、颜色简单且对比强烈的图片和背景。

* GIF

关键字：动态图、体积小支持透明
优点：可以压缩体积非常小。可插入多帧实现动画效果。支持透明色浮现于背景之上。
缺点：最多只能处理 256 中颜色，不适用于真彩图像。
使用场景：小动画。

* SVG

关键字：文本文件、体积小、不失真、兼容性好
优点：文本体积更小，可压缩性更强。图片可以无限放大不失真。文本文件可以直接在 HTML 中写入，灵活性高。
缺点：渲染成本高、学习成本（可编程）
使用场景：变成代码嵌入 HTML 中，也可以换成 .svg 后缀的文件进行引用。

* Base64

关键字：文本文件、依赖编码、小图标解决方案
优点：作为雪碧图的补充而存在，减少加载页面图片时对服务器的请求次数。（img src 会发起资源请求，但是 Base64 得到的是字符串，嵌入 HTML 中）
缺点：大图使用 Base64 会增大体积，影响性能
使用场景：小 Logo（不超过 2kb）、更新频率低的图片。
编码工具：Webpack 的 url-loader 可以根据文件大小来判断是否编码成 Base64。

* 雪碧图

雪碧图、CSS 精灵、CSS Sprites、图像精灵，都是同一个玩意。
它是将小图标和背景图像合并到一张图片上，然后通过 CSS 背景定位来显示其中的每一个具体部分。
它是一种优化手段，因为单张图片所需的 HTTP 请求更少，对内存和带宽更加友好。

* WebP

关键字：年轻的全能型选手
优点：支持有损压缩和无损压缩、支持透明、可以跟 GIF 一样显示动态图
缺点：兼容性差
使用场景：暂无大型应用场景

## Gzip 压缩

* Webpack 开启 Gzip

通过 compression-webpack-plugin 可以开启 Gzip 压缩。

* 是否值得开启 Gzip

如果压缩文件太小，那不使用；但是如果具有一定规模的项目文件，可以开启 Gzip。

* Gzip 原理

Gzip 并不是万能的，它的原理是在一个文本文件中找一些重复出现的字符串、临时替换它们，从而使整个文件变小，所以对于图片等会处理不了。

* 服务器端和 Webpack 的 Gzip 并存

服务器压缩也需要时间开销和 CPU 开销，所以有时候可以用 Webpack 来进行 Gzip 压缩，从而为服务器分压。

## 服务端渲染

1. 首屏或其他模块加载速度快、
2. 为了更好的 SEO 效果

但同时：提高了服务器压力，吃 CPU，内存等资源，优化不好提高成本。

##  浏览器渲染机制

